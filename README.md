# Client-server_model

HW Client_Server
1) Прочиать про клиент-серверную архитектуру

2) Что ткое HTTP и HTTPS
```
HTTP — это протокол передачи данных между браузером и сервером: страниц, файлов, видеозаписей. HTTPS — это тот же HTTP, но с добавленными методами шифрования данных и проверки безопасности.

«HTTP, или Hyper Text Transfer Protocol, — это протокол передачи гипертекстовой разметки, которая используется для передачи данных в интернете».

HTTPS — это не совсем протокол. Это расширение HTTP-протокола — объединение двух протоколов: HTTP и SSL или HTTP и TLS. 

Протоколы TLS (Transport Layer Security) и SSL (Secure Socket Layer) — криптографические. Это значит, что они позволяют шифровать данные, в нашем случае те, что передаются между браузером и сервером. Расшифровать эти данные могут только сервер и браузер, для всех остальных это будет набор нечитаемых символов.

Примечание: TLS основан на SSL, но второй уже устарел, и вместо него используют TLS. 
```
3) HTTP методы
```
HTTP определяет множество методов запроса, которые указывают, какое желаемое действие выполнится для данного ресурса. Несмотря на то, что их названия могут быть существительными, эти методы запроса иногда называются HTTP глаголами. Каждый реализует свою семантику, но каждая группа команд разделяет общие свойства: так, методы могут быть безопасными, идемпотентными или кешируемыми.

 GET
Метод GET запрашивает представление ресурса. Запросы с использованием этого метода могут только извлекать данные.
 HEAD
HEAD запрашивает ресурс так же, как и метод GET, но без тела ответа.
 POST
POST используется для отправки сущностей к определённому ресурсу. Часто вызывает изменение состояния или какие-то побочные эффекты на сервере.
 PUT
PUT заменяет все текущие представления ресурса данными запроса.
 DELETE
DELETE удаляет указанный ресурс.
 CONNECT
CONNECT устанавливает "туннель" к серверу, определённому по ресурсу.
 OPTIONS
OPTIONS используется для описания параметров соединения с ресурсом.
 TRACE
TRACE выполняет вызов возвращаемого тестового сообщения с ресурса.
 PATCH
PATCH используется для частичного изменения ресурса.
```
4) HTTP статус коды сервера
```
Во время запроса информации браузером или поисковым роботом ему отдается определенный HTTP код состояния сервера. Коды состояния HTTP протокола состоят из трех цифр от 100 и до 526. Диапазон значений кодов сервера постоянно расширяется и вводятся новые значения.

Существуют основные группы ответов сервера:

Информационные (1хх) – коды этой группы дают понять, что на данный момент запросы обрабатываются в штатном режиме.

Свидетельствующие об успешном завершении запроса (2хх) – коды означают, что те данные, которые браузер запрашивал у сервера, были успешно ему переправлены. 

Коды переадресации (3хх) – коды сообщают пользователю, что для успешного выполнения, поданного пользователем запроса, необходимо сделать еще один запрос к другому URI. 

Ошибка со стороны клиента (4хх) – коды означают, что в результате неверно сформированного запроса он не может быть обработан сервером. 

Ошибка со стороны сервера (5хх) – коды дают понять, что сбой в обработке корректно сформированного запроса произошел из-за ошибки на сервере.

Основные и часто встречающие типы ответов сервера это: 200, 404, 500 и 301

200 ОК - Страница с кодом 200 ОК говорит об успешной обработке запроса. Это значит, что сервер работает нормально, а поисковый робот получил возможность ее проиндексировать.

301 Moved Permanently - Код переадресации означает, что URL страницы изменен. Страница по запросу недоступна по прошлому адресу и у нее теперь  есть новый URL.

302 Found - Код означает, что страница временно недоступна по данному адресу, но у нее есть новый временный URL.

304 Not Modified - Этот ответ сервера говорит, что на запрашиваемой странице не было обновлений с момента последнего ее посещения. Получая такой ответ браузер или поисковый робот не будут полностью ее запрашивать с сервера, а возьму сохраненную копию из собственного кеша.

403 Forbidden - Данный код ошибки (ответ сервера) говорит о запрете на просмотр страницы. Его можно увидеть, если пользователь получил отказ в доступе, например, при ограничении по IP-адресу или попытке просмотра системных файлов сайта.

404 Not Found - Ответ сервера (код ошибки) показывающий, что заданная страница (ресурс) больше не существует.

500 Internet Server Error - Этот код ошибки (ответ сервера) сообщает, что произошла ошибка на стороне сервера.

502 Bad Gateway — Номер ошибки сервера, говорящий что прокси сервер не может получить ответ от сайта.

503 Service Unavailable - Ответ сервера (код ошибки) означает, что запроса сервис оказался перегружен и в данный момент не доступен.

504 Gateway Timeout - Этот номер ошибки появляется в результате слишком долгого ответа, когда прокси-сервер не получил результат запроса от вышестоящего сервиса.
```
5) Что такое ядро браузера 
```
Обычно браузер занимается тем, что получает данные с сервера по протоколу HTTP, компонует их в виде изображения или текстового фрейма, а результат помещает на экран. Компонент браузера, обрабатывающий HTML, называется HTML-парсером, а модуль, подготавливающий графическое представление HTML-документа, — рендером. Ядром браузера мы будем называть совокупность HTML-парсера, рендера и еще нескольких базовых модулей, включая обработчик сценариев Java и JavaScript. Все остальные функции являются внешними и выполняются оболочкой.

```
6) Какие браузеры какиие ядра используют
```
Браузеры на движке WebKit
Движок с открытым кодом, который разрабатывается Apple Computer.
Safari
Konqueror

Браузеры на движке Blink

Создан на основе WebKit, Blink используется для браузера Chromium и как следствие для его производных.
Chromium
Google Chrome
Яндекс.Браузер
Opera
Vivaldi
Microsoft Edge

Браузеры на движке Gecko
Движок с открытым кодом Gecko разработан Mozilla Foundation.
Mozilla Firefox
SeaMonkey
Avant Browser
K-Meleon
Netscape Browser (использует как Gecko, так и Trident)

Браузеры на движках KHTML
Движок с открытым кодом, разработанный в рамках KDE, послужил основой для WebKit.
Konqueror
ABrowse

Браузеры на движке Trident
Microsoft переходит на Blink.
Trident разработан Microsoft для Internet Explorer.
Internet Explorer
Maxthon (прежде известный как MyIE2)
Slim Browser
GreenBrowser

Браузер на движке Presto - более не используется
Opera перешла на движок Blink.
Движок Opera (Presto) лицензирован Adobe и интегрирован в пакет Adobe Creative Suite.
Opera
```
7) Что такое API
```
API (англ. Application Programming Interface — программный интерфейс приложения) — это набор способов и правил, по которым различные программы общаются между собой и обмениваются данными.
```
8) Что такое ендпоинты
```
Эндпоинт (в переводе с англ. — конечная точка) представляет собой некий шлюз, который соединяет серверные процессы приложения с внешним интерфейсом. Простыми словами, это адрес, на который отправляются сообщения.

Чтобы понять, что такое эндпоинты, важно упомянуть работу API. API — аббревиатура от application programming interface, что переводится как программный интерфейс приложения. Приложения используют API для взаимодействия со сторонними приложениями и своими пользователями.

Чтобы связаться с API, нужно отправить ему запрос. Для корректной обработки запроса клиент должен предоставить универсальный указатель ресурса (URL), метод (HTTP method), и в зависимости от метода добавить заголовки (headers), тело (body), параметры запроса. Заголовки предоставляют метаданные о запросе, а тело содержит данные, например, поля для новой строки в базе данных.


```
9) URL (URI, URL, URN)
```
URI (Uniform Resource Identifier) – это строка символов, которая используется для идентификации какого-либо ресурса по его адресу или по его имени, либо по тому и тому вместе.
URL (Uniform Resource Locator) – это строка символов, которая используется для идентификации какого-либо ресурса, но только по его адресу, по его местоположению.
URN (Uniform Resource Name) – это строка символов, которая используется для идентификации какого-либо ресурса, но только по его имени.

URI – имя и адрес ресурса в сети, включает в себя URL и URN
URL – адрес ресурса в сети, определяет местонахождение и способ обращения к нему
URN – имя ресурса в сети, определяет только название ресурса, но не говорит как к нему подключиться

Рассмотрим примеры:

URI – https://wiki.merionet.ru/images/vse-chto-vam-nuzhno-znat-pro-devops/1.png
URL - https://wiki.merionet.ru
URN - images/vse-chto-vam-nuzhno-znat-pro-devops/1.png
```
10) Идемпотентные HTTP методы
```
Метод HTTP является идемпотентным, если повторный идентичный запрос, сделанный один или несколько раз подряд, имеет один и тот же эффект, не изменяющий состояние сервера. Другими словами, идемпотентный метод не должен иметь никаких побочных эффектов (side-effects), кроме сбора статистики или подобных операций. Корректно реализованные методы GET, HEAD, PUT и DELETE идемпотентны, но не метод POST. Также все безопасные методы являются идемпотентными.

Для идемпотентности нужно рассматривать только изменение фактического внутреннего состояния сервера, а возвращаемые запросами коды статуса могут отличаться: первый вызов DELETE вернёт код 200, в то время как последующие вызовы вернут код 404. Из идемпотентности DELETE неявно следует, что разработчики не должны использовать метод DELETE при реализации RESTful API с функциональностью удалить последнюю запись.

Обратите внимание, что идемпотентность метода не гарантируется сервером, и некоторые приложения могут нарушать ограничение идемпотентности.
```
11) Безопасные HTTP методы
```
На данный момент принято соглашение о том, что HTTP методы GET и HEAD никогда не должны иметь иного значения, кроме загрузки, поэтому данные HTTP методы нужно рассматривать, как безопасные, это требование HTTP. Поэтому ваш браузер, когда используются методы POST, PUT или DELETE предупреждает вас о том, что может произойти потенциально опасное действие и спрашивает: нужно ли его выполнить.
```
12) Иденфикация, Аутентификация, Авторизация
```
Идентификация — процесс распознавания пользователя по его идентификатору
Аутентификация — процедура проверки подлинности, доказательство что пользователь именно тот, за кого себя выдает
Авторизация — предоставление определённых прав

 Например пользователь хочет войти в свой аккаунт Google. Google подходит лучше всего, потому что там процедура входа явным образом разбита на несколько простейших этапов. Вот что при этом происходит:

Для начала система запрашивает логин, пользователь его указывает, система распознает его как существующий — это идентификация.
После этого Google просит ввести пароль, пользователь его вводит, и система соглашается, что пользователь, похоже, действительно настоящий, раз пароль совпал, — это аутентификация.
Скорее всего, Google дополнительно спросит еще и одноразовый код из SMS или приложения. Если пользователь и его правильно введет, то система окончательно согласится с тем, что он настоящий владелец аккаунта, — это двухфакторная аутентификация.
После этого система предоставит пользователю право читать письма в его почтовом ящике и все в таком духе — это авторизация.
```
13) Что такое IP
```
IP-адрес (от англ. Internet Protocol) — уникальный числовой идентификатор устройства в компьютерной сети, работающей по протоколу IP.

В сети Интернет требуется глобальная уникальность адреса; в случае работы в локальной сети требуется уникальность адреса в пределах сети. В версии протокола IPv4 IP-адрес имеет длину 4 байта, а в версии протокола IPv6 — 16 байт.

В 4-й версии IP-адрес представляет собой 32-битное число. Как правило, адрес записывается в виде четырёх десятичных чисел значением от 0 до 255 (эквиваленты четырём восьмибитным числам), разделённых точками, например, 192.168.0.3.

В 6-й версии IP-адрес является 128-битным. Как правило, адрес записывается в виде восьми четырёхзначных шестнадцатеричных чисел (эквивалентны восьми 16-битным числам), разделённых двоеточиями, например, 2001:0db8:85a3:0000:0000:8a2e:0370:7334. Ведущие нули допускается в записи опускать. Нулевые группы, идущие подряд, могут быть опущены, вместо них ставится двойное двоеточие (fe80:0:0:0:0:0:0:1 можно записать как fe80::1). Более одного такого пропуска в адресе не допускается.
```
14) Что такое октаты в DNS
```
Служба доменных имен (DNS, domain name system) — это стандартный протокол, который позволяет пользователям получать доступ к веб-сайтам, используя удобочитаемые адреса. Как телефонная книга позволяет найти имя контакта и узнать его телефонный номер, так и DNS позволяет ввести адрес веб-сайта и автоматически определить его IP-адрес, то есть уникальный идентификатор конкретного устройства (сервера) в компьютерной сети.
Октет, квадрант

Каждое из 8-битных чисел иногда носит название октета ( octet )
или квадранта ( quad ).
 192.168.18.3.
192. -первый октет квадрант 168. -второй октет 18. -третий октет 1. -четвертый октет
```
15) Что такое порт, сколько портов у Linux сервера
```
Порт (англ. port) — целое неотрицательное число, записываемое в заголовках протоколов транспортного уровня сетевой модели OSI (TCP, UDP, SCTP, DCCP).

Номера портов могут указываться в адресах веб-сайтов (URL) или в идентификаторах других ресурсов, доступных в компьютерных сетях (URI). По умолчанию в протоколе HTTP используется порт 80, а в протоколе HTTPS — порт 443. URL вида http://www.example.com:8080/path/ указывает, что веб-ресурс обслуживается веб-сервером на порту 8080.

Протокол управления передачей (TCP) и протокол пользовательских дейтаграмм (UDP) используют номера портов для связи.

Это значение от 0 до 65535.

Ниже приведены категории присвоений портов.

0-1023: Хорошо известные порты или системные порты
1024-49151: Зарегистрированные порты для приложений
49152-65535: Динамические порты или частные порты
```
16) Уровни OSI
```
Сетевая модель OSI имеет семь уровней, иерархически расположенных от большего к меньшему. То есть, самым верхним является седьмой (прикладной), а самым нижним — первый (физический). 

Первый, физический уровень (physical layer, L1)
Начнем с самого нижнего уровня. Он отвечает за обмен физическими сигналами между физическими устройствами, «железом». Компьютерное железо не понимает, что такое картинка или что на ней изображено, железу картинка понятна только в виде набора нулей и единиц, то есть бит. В данном случае бит является блоком данных протокола, сокращенно PDU (Protocol Data Unit).

Каждый уровень имеет свои PDU, представляемые в той форме, которая будет понятна на данном уровне и, возможно, на следующем до преобразования. Работа с чистыми данными происходит только на уровнях с пятого по седьмой.

Устройства физического уровня оперируют битами. Они передаются по проводам (например, через оптоволокно) или без проводов (например, через Bluetooth или IRDA, Wi-Fi, GSM, 4G и так далее).

Второй уровень, канальный (data link layer, L2)
Когда два пользователя находятся в одной сети, состоящей только из двух устройств — это идеальный случай. Но что если этих устройств больше?

Второй уровень решает проблему адресации при передаче информации. Канальный уровень получает биты и превращает их в кадры (frame, также «фреймы»). Задача здесь — сформировать кадры с адресом отправителя и получателя, после чего отправить их по сети.

У канального уровня есть два подуровня — это MAC и LLC. MAC (Media Access Control, контроль доступа к среде) отвечает за присвоение физических MAC-адресов, а LLC (Logical Link Control, контроль логической связи) занимается проверкой и исправлением данных, управляет их передачей.

На втором уровне OSI работают коммутаторы, их задача — передать сформированные кадры от одного устройства к другому, используя в качестве адресов только физические MAC-адреса.

Третий уровень, сетевой (network layer, L3)
На третьем уровне появляется новое понятие — маршрутизация. Для этой задачи были созданы устройства третьего уровня — маршрутизаторы (их еще называют роутерами). Маршрутизаторы получают MAC-адрес от коммутаторов с предыдущего уровня и занимаются построением маршрута от одного устройства к другому с учетом всех потенциальных неполадок в сети.

На сетевом уровне активно используется протокол ARP (Address Resolution Protocol — протокол определения адреса). С помощью него 64-битные MAC-адреса преобразуются в 32-битные IP-адреса и наоборот, тем самым обеспечивается инкапсуляция и декапсуляция данных.

Четвертый уровень, транспортный (transport layer, L4)
Все семь уровней модели OSI можно условно разделить на две группы:

Media layers (уровни среды),
Host layers (уровни хоста).
Уровни группы Media Layers (L1, L2, L3) занимаются передачей информации (по кабелю или беспроводной сети), используются сетевыми устройствами, такими как коммутаторы, маршрутизаторы и т.п. Уровни группы Host Layers (L4, L5, L6, L7) используются непосредственно на устройствах, будь то стационарные компьютеры или портативные мобильные устройства.

Четвертый уровень — это посредник между Host Layers и Media Layers, относящийся скорее к первым, чем к последним, его главной задачей является транспортировка пакетов. Естественно, при транспортировке возможны потери, но некоторые типы данных более чувствительны к потерям, чем другие. Например, если в тексте потеряются гласные, то будет сложно понять смысл, а если из видеопотока пропадет пара кадров, то это практически никак не скажется на конечном пользователе. Поэтому, при передаче данных, наиболее чувствительных к потерям на транспортном уровне используется протокол TCP, контролирующий целостность доставленной информации.

Для мультимедийных файлов небольшие потери не так важны, гораздо критичнее будет задержка. Для передачи таких данных, наиболее чувствительных к задержкам, используется протокол UDP, позволяющий организовать связь без установки соединения.

При передаче по протоколу TCP, данные делятся на сегменты. Сегмент — это часть пакета. Когда приходит пакет данных, который превышает пропускную способность сети, пакет делится на сегменты допустимого размера. Сегментация пакетов также требуется в ненадежных сетях, когда существует большая вероятность того, что большой пакет будет потерян или отправлен не тому адресату. При передаче данных по протоколу UDP, пакеты данных делятся уже на датаграммы. Датаграмма (datagram) — это тоже часть пакета, но ее нельзя путать с сегментом.

Главное отличие датаграмм в автономности. Каждая датаграмма содержит все необходимые заголовки, чтобы дойти до конечного адресата, поэтому они не зависят от сети, могут доставляться разными маршрутами и в разном порядке. Датаграмма и сегмент — это два PDU транспортного уровня модели OSI. При потере датаграмм или сегментов получаются «битые» куски данных, которые не получится корректно обработать.

Первые четыре уровня — специализация сетевых инженеров, но с последними тремя они не так часто сталкиваются, потому что пятым, шестым и седьмым занимаются разработчики.

Пятый уровень, сеансовый (session layer, L5)
Пятый уровень оперирует чистыми данными; помимо пятого, чистые данные используются также на шестом и седьмом уровне. Сеансовый уровень отвечает за поддержку сеанса или сессии связи. Пятый уровень оказывает услугу следующему: управляет взаимодействием между приложениями, открывает возможности синхронизации задач, завершения сеанса, обмена информации.

Службы сеансового уровня зачастую применяются в средах приложений, требующих удаленного вызова процедур, т.е. чтобы запрашивать выполнение действий на удаленных компьютерах или независимых системах на одном устройстве (при наличии нескольких ОС).

Примером работы пятого уровня может служить видеозвонок по сети. Во время видеосвязи необходимо, чтобы два потока данных (аудио и видео) шли синхронно. Когда к разговору двоих человек прибавится третий — получится уже конференция. Задача пятого уровня — сделать так, чтобы собеседники могли понять, кто сейчас говорит.

Шестой уровень, представления данных (presentation layer, L6)
О задачах уровня представления вновь говорит его название. Шестой уровень занимается тем, что представляет данные (которые все еще являются PDU) в понятном человеку и машине виде. Например, когда одно устройство умеет отображать текст только в кодировке ASCII, а другое только в UTF-8, перевод текста из одной кодировки в другую происходит на шестом уровне.

Шестой уровень также занимается представлением картинок (в JPEG, GIF и т.д.), а также видео-аудио (в MPEG, QuickTime). Помимо перечисленного, шестой уровень занимается шифрованием данных, когда при передаче их необходимо защитить.
Седьмой уровень, прикладной (application layer)
Седьмой уровень иногда еще называют уровень приложений, но чтобы не запутаться можно использовать оригинальное название — application layer. Прикладной уровень — это то, с чем взаимодействуют пользователи, своего рода графический интерфейс всей модели OSI, с другими он взаимодействует по минимуму.

Все услуги, получаемые седьмым уровнем от других, используются для доставки данных до пользователя. Протоколам седьмого уровня не требуется обеспечивать маршрутизацию или гарантировать доставку данных, когда об этом уже позаботились предыдущие шесть. Задача седьмого уровня — использовать свои протоколы, чтобы пользователь увидел данные в понятном ему виде.

Протоколы здесь используют UDP (например, DHCP) или TCP (например, HTTP, HTTPS, SFTP (Simple FTP), DNS). Прикладной уровень является самым верхним по иерархии, но при этом его легче всего объяснить.

На седьмом уровне информация представляется в виде данных, на первом — в виде бит. Процесс, когда информация отправляется и переходит из данных в биты, называется инкапсуляцией. Обратный процесс, когда информация, полученная в битах на первом уровне, переходит в данные на седьмом, называется декапсуляцией. На каждом из семи уровней информация представляется в виде блоков данных протокола — PDU (Protocol Data Unit).

Рассмотрим на примере: пользователь 1 отправляет картинку, которая обрабатывается на седьмом уровне в виде данных, данные должны пройти все уровни до самого нижнего (первого), где будут представлены как биты. Этот процесс называется инкапсуляцией. Компьютер пользователя 2 принимает биты, которые должны снова стать данными. Этот обратный процесс называется декапсуляция.


```
Разница между сетевыми моделями TСP/IP и OSI можно посмотреть [здесь](https://github.com/AndreiBra/TCP.IP-OSI) 

17) Хедеры http запросов
```
HTTP-протокол состоит только из текста. 

Каждое сообщение состоит из трех частей:
Стартовая строка (Starting line) — определяет служебные данные.
Заголовки (Headers) — описание параметров сообщения.
Тело сообщения (Body) — данные сообщения. Должны отделяться от заголовков пустой строкой.
По HTTP-протоколу можно отправить запрос на сервер (request) и получить ответ от сервера (response). Запросы и ответы немного отличаются параметрами.

Заголовки HTTP в запросах HTTP

Наиболее распространенные HTTP headers, найденных в HTTP requests.

Почти все эти заголовки можно найти в массиве $ _SERVER в PHP. Вы также можете использовать функцию getallheaders() для извлечения всех заголовков одновременно.

Host
HTTP-запрос отправляется на определенные IP-адреса. Но так как большинство серверов способны размещать несколько сайтов под одним IP, они должны знать, какое доменное имя ищет браузер.

1 Host: net.tutsplus.com

Это в основном имя host, включая домен и поддомен.

В PHP его можно найти, как $_SERVER['HTTP_HOST'] или $_SERVER['SERVER_NAME'].

User-Agent

1 User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.5) Gecko/20091102 Firefox/3.5.5 (.NET CLR 3.5.30729)

Этот заголовок может содержать несколько частей информации, таких как:

Имя и версия браузера.
Название и версия операционной системы.
Язык по умолчанию.
Именно так веб-сайты могут собирать определённую общую информацию о своих системах surfers. Например, они могут определить, использует ли surfer  мобильный браузер и перенаправляет их на мобильную версию своего веб-сайта, который лучше работает с низким разрешением.

В PHP может быть выражен так: $_SERVER['HTTP_USER_AGENT'].

1 if ( strstr($_SERVER['HTTP_USER_AGENT'],'MSIE 6') ) {
2  echo "Please stop using IE6!";
3 }

Accept-Language
1 Accept-Language: en-us,en;q=0.5
Этот заголовок отображает настройки языка по умолчанию.   Если сайт имеет разные языковые версии, он может перенаправить нового surfer на основе этих данных.

Он может содержать несколько языков, разделённых запятыми. Первый - это предпочтительный язык, и каждый из перечисленных языков может иметь значение «q», которое представляет собой оценку предпочтения пользователя для языка (min. 0 max. 1).

В PHP его можно найти так: $ _SERVER ["HTTP_ACCEPT_LANGUAGE"].

1 if (substr($_SERVER['HTTP_ACCEPT_LANGUAGE'], 0, 2) == 'fr') {
2    header('Location: http://french.mydomain.com');
3 }

Accept-Encoding

1 Accept-Encoding: gzip,deflate
Большинство современных браузеров поддерживают gzip и отправляют это в header. Затем веб-сервер может отправить выходной HTML-код в сжатом формате. Это позволяет уменьшить размер до 80% для экономии пропускной способности и времени.

В PHP его можно найти так: $ _SERVER ["HTTP_ACCEPT_ENCODING"]. Однако, когда вы используете функцию обратного вызова ob_gzhandler(), она будет проверять значение автоматически, поэтому вам это не нужно.

1 // enables output buffering
2 // and all output is compressed if the browser supports it
3 ob_start('ob_gzhandler');

If-Modified-Since

Если веб-документ уже сохранен в кеше в браузере и вы посещаете его снова, ваш браузер может проверить, был ли документ обновлён, отправив следующее:

1 If-Modified-Since: Sat, 28 Nov 2009 06:38:19 GMT

Если он не изменялся с этой даты, сервер отправляет код ответа «304 Not Modified», а содержимое - нет, и браузер загружает содержимое из cache.

В PHP его можно найти так: $ _SERVER ['HTTP_IF_MODIFIED_SINCE'].

01 // assume $last_modify_time was the last the output was updated
02 
03 // did the browser send If-Modified-Since header?
04 if(isset($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {
05 
06    // if the browser cache matches the modify time
07    if ($last_modify_time == strtotime($_SERVER['HTTP_IF_MODIFIED_SINCE'])) {
08 
09        // send a 304 header, and no content
10        header("HTTP/1.1 304 Not Modified");
11        exit;
12    }
13 
14 }

Существует также HTTP-заголовок Etag, который можно использовать для проверки текущего кэша. 

Cookie

Как следует из названия, это отправляет файлы cookie, хранящиеся в вашем браузере для этого домена.

1 Cookie: PHPSESSID=r2t5uvjq435r4q7ib3vtdjq120; foo=bar

Это пары name=value, разделённые точками с запятой. Cookies могут также содержать id сеанса.

В PHP отдельные cookie-файлы могут быть доступны с помощью массива $ _COOKIE. Вы можете напрямую обращаться к переменным сеанса, используя массив $ _SESSION, и если вам нужен id сеанса, вы можете использовать функцию session_id () вместо cookie.

1 echo $_COOKIE['foo'];
2 // output: bar
3 echo $_COOKIE['PHPSESSID'];
4 // output: r2t5uvjq435r4q7ib3vtdjq120
5 session_start();
6 echo session_id();
7 // output: r2t5uvjq435r4q7ib3vtdjq120

Referer

Как следует из названия, этот HTTP header содержит ссылочный url.

Например, если я зашел на домашнюю страницу Nettuts + и нажал ссылку на статью, этот header будет отправлен в мой браузер:

1 Referer: https://net.tutsplus.com/

В PHP его можно найти как $ _SERVER ['HTTP_REFERER'].

01 if (isset($_SERVER['HTTP_REFERER'])) {
02 
03    $url_info = parse_url($_SERVER['HTTP_REFERER']);
04 
05    // is the surfer coming from Google?
06    if ($url_info['host'] == 'www.google.com') {
07 
08        parse_str($url_info['query'], $vars);
09 
10        echo "You searched on Google for this keyword: ". $vars['q'];
11 
12    }
13 
14 }
15 // if the referring url was:
16 // http://www.google.com/search?source=ig&hl=en&rlz=&=&q=http+headers&aq=f&oq=&aqi=g-p1g9
17 // the output will be:
18 // You searched on Google for this keyword: http headers

Возможно, вы заметили, что слово «referrer» написано с ошибкой, как «referer». К сожалению, он превратился в официальную спецификацию HTTP подобным образом и застрял.

Authorization

Когда веб-страница запрашивает авторизацию, браузер открывает окно входа в систему. Когда вы вводите имя пользователя и пароль в этом окне, браузер отправляет другой HTTP-запрос, но на этот раз он содержит этот header

1 Authorization: Basic bXl1c2VyOm15cGFzcw==

Данные внутри header имеют кодировку base64. Например, base64_decode ('bXl1c2VyOm15cGFzcw ==') возвратит 'myuser: mypass'

В PHP эти значения можно найти как $ _SERVER ['PHP_AUTH_USER'] и $ _SERVER ['PHP_AUTH_PW'].



Заголовки HTTP в ответах HTTP

Теперь мы рассмотрим некоторые из наиболее распространенных HTTP headers, найденных в HTTP-ответах.

В PHP вы можете установить заголовки ответа, используя функцию header(). PHP уже отправляет определённые заголовки автоматически, для загрузки содержимого и настройки файлов cookie и прочее... Вы можете увидеть headers, которые отправляются или будут отправляться с помощью функции headers_list (). Вы можете проверить, были ли уже отправлены заголовки с помощью функции headers_sent().

Cache-Control
Определение из w3.org: «Поле заголовка Cache-Control используется для указания директив, которые ДОЛЖНЫ выполняться всеми механизмами кэширования по цепочке запросов/ответов». Эти «механизмы кэширования» включают шлюзы и прокси, которые может использовать ваш интернет-провайдер.

Пример:

1 Cache-Control: max-age=3600, public

"public" означает, что ответ может быть кэширован кем угодно. "max-age" указывает, сколько секунд действителен кеш. Разрешение кэширования вашего сайта может снизить нагрузку на сервер и пропускную способность, а также увеличить время загрузки в браузере.

Кэширование также может быть предотвращено с помощью директивы "no-cache".

1 Cache-Control: no-cache


Content-Type

Этот header указывает "mime-type" документа. Затем браузер определяет, как интерпретировать содержимое на основании этого. Например, страница html (или PHP-скрипт с выходом html) может возвращать это:

1 Content-Type: text/html; charset=UTF-8
"text" - это тип, а "html" - подтип документа. Заголовок также может содержать больше информации, такой как charset.

Для gif-изображения это может быть отправлено.

1 Content-Type: image/gif
Браузер может использовать внешнее приложение или расширение браузера на основе mime-type. Например, это приведет к загрузке Adobe Reader:

1 Content-Type: application/pdf

При загрузке напрямую Apache обычно может обнаружить mime-тип документа и отправить соответствующий header. Кроме того, большинство браузеров имеют некоторую степень отказоустойчивости и автоопределение типов mime, если заголовки указаны неверно или отсутствуют.

Вы можете найти список общих типов mime here.

В PHP вы можете использовать функцию finfo_file() для определения mime-типа файла.

Content-Disposition

Этот header указывает браузеру открыть окно загрузки файла, вместо того, чтобы пытаться проанализировать содержимое. Пример:

1 Content-Disposition: attachment; filename="download.zip"

Это заставит браузер сделать это:


Обратите внимание, что соответствующий заголовок Content-Type также должен быть отправлен вместе с этим:

1 Content-Type: application/zip
2 Content-Disposition: attachment; filename="download.zip"

Content-Length 

Когда контент будет передаваться браузеру, сервер может указать его размер (в байтах), используя этот header.

1 Content-Length: 89123 

Это особенно полезно при загрузке файлов. Именно так браузер может определить ход загрузки.

Например, вот сценарий-макет,  имитирует медленную загрузку.

01 // it's a zip file
02 header('Content-Type: application/zip');
03 // 1 million bytes (about 1megabyte)
04 header('Content-Length: 1000000');
05 // load a download dialogue, and save it as download.zip
06 header('Content-Disposition: attachment; filename="download.zip"');
07 
08 // 1000 times 1000 bytes of data
09 for ($i = 0; $i < 1000; $i++) {
10    echo str_repeat(".",1000);
11 
12   // sleep to slow down the download
13    usleep(50000);
14 }




Теперь я собираюсь закомментировать заголовок Content-Length

01 // it's a zip file
02 header('Content-Type: application/zip');
03 // the browser won't know the size
04 // header('Content-Length: 1000000');
05 // load a download dialogue, and save it as download.zip
06 header('Content-Disposition: attachment; filename="download.zip"');
07 
08 // 1000 times 1000 bytes of data
09 for ($i = 0; $i < 1000; $i++) {
10    echo str_repeat(".",1000);
11 
12    // sleep to slow down the download
13    usleep(50000);
14 }



Браузер может только сказать, сколько байтов было загружено, но он не знает общую сумму. И индикатор выполнения не показывает прогресс.

Etag
 
Это еще один header, который используется для кеширования. Это выглядит так:

1 Etag: "pub1259380237;gz"

Веб-сервер может отправлять этот header с каждым документом, который он обслуживает. Значение может быть основано на последней изменённой дате, размере файла или даже контрольной сумме файла. Браузер затем сохраняет это значение, так как он кэширует документ. В следующий раз, когда браузер запрашивает тот же файл, он отправляет это в HTTP-запросе:

1 If-None-Match: "pub1259380237;gz"
Если значение Etag документа совпадает с этим, сервер будет отправлять код 304 вместо 200, и никакого содержимого. Браузер будет загружать содержимое из своего кеша.

Last-Modified

Как следует из названия, этот header указывает дату последнего изменения документа в формате GMT:

1 Last-Modified: Sat, 28 Nov 2009 03:50:37 GMT

1 $modify_time = filemtime($file);
2 
3 header("Last-Modified: " . gmdate("D, d M Y H:i:s", $modify_time) . " GMT");

Это предлагает браузеру другой способ для cache документа. Браузер может отправить это в HTTP-запросе:

1 If-Modified-Since: Sat, 28 Nov 2009 06:38:19 GMT
Мы уже говорили об этом ранее в разделе "If-Modified-Since".

Location

Этот заголовок используется для перенаправления. Если код ответа 301 или 302, сервер также должен отправить этот header. Например, когда вы перейдете на страницу http://www.nettuts.com, ваш браузер получит следующее:

1 HTTP/1.x 301 Moved Permanently
2 ...
3 Location: https://net.tutsplus.com/
4 ...

В PHP вы можете перенаправить surfer так:

1 header('Location: https://net.tutsplus.com/');
По умолчанию, это отправит 302 код ответа. Если вы хотите вместо 301 отправить:

1 header('Location: https://net.tutsplus.com/', true, 301);

Set-Cookie

Когда веб-сайт хочет установить или обновить файл cookie в вашем браузере, он будет использовать этот header.

1 Set-Cookie: skin=noskin; path=/; domain=.amazon.com; expires=Sun, 29-Nov-2009 21:42:28 GMT
2 Set-Cookie: session-id=120-7333518-8165026; path=/; domain=.amazon.com; expires=Sat Feb 27 08:00:00 2010 GMT

Каждый файл cookie отправляется как отдельный header. Обратите внимание, что файлы cookie, установленные с помощью JavaScript, не проходят через HTTP headers.

В PHP вы можете установить cookie-файлы, используя функцию setcookie(), а PHP отправляет соответствующие HTTP headers.

1 setcookie("TestCookie", "foobar");

Что приводит к отправке этого заголовка:

1 Set-Cookie: TestCookie=foobar

Если дата истечения срока действия не указана, cookie удаляется, когда окно браузера закрыто.

WWW-Authenticate

Сайт может отправить этот header для аутентификации пользователя через HTTP. Когда браузер увидит этот header, он откроет диалоговое окно входа в систему.

1 WWW-Authenticate: Basic realm="Restricted Area"

Что будет выглядеть так:


В руководстве PHP есть section, в котором приведены образцы кода, как это сделать в PHP.

1 if (!isset($_SERVER['PHP_AUTH_USER'])) {
2    header('WWW-Authenticate: Basic realm="My Realm"');
3    header('HTTP/1.0 401 Unauthorized');
4    echo 'Text to send if user hits Cancel button';
5    exit;
6  } else {
7    echo "<p>Hello {$_SERVER['PHP_AUTH_USER']}.</p>";
8    echo "<p>You entered {$_SERVER['PHP_AUTH_PW']} as your password.</p>";
9 }

Content-Encoding

Этот header обычно устанавливается, когда возвращаемое содержимое сжимается.

1 Content-Encoding: gzip
В PHP, если вы используете функцию обратного вызова ob_gzhandler(), она будет автоматически установлена.
```
